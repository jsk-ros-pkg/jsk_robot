(load "package://jsk_robot_startup/lifelog/tweet_client.l")
(load "package://jsk_fetch_startup/euslisp/notify-app.l")
(if (ros::rospack-find "switchbot_ros")
    (load "package://switchbot_ros/scripts/switchbot.l"))

(ros::load-ros-manifest "fetch_auto_dock_msgs")
(ros::load-ros-manifest "jsk_robot_startup")
(ros::load-ros-manifest "jsk_recognition_msgs")
(ros::load-ros-manifest "power_msgs")
(ros::load-ros-manifest "sensor_msgs")

(defparameter *dock-action* nil)
(defparameter *undock-action* nil)
(defparameter *spots* nil)
(defparameter *tfl* (instance ros::transform-listener :init))

(let ((robot-name (ros::get-param "/robot/name")))
  (defparameter *dock-spot*
    (cond
      ((equal robot-name "fetch15")
       "/eng2/7f/room73B2-fetch-dock-front")
      ((equal robot-name "fetch1075")
       "/eng2/7f/room73B2-fetch-dock2-front")
      (t "/eng2/7f/room73B2-fetch-dock2-front"))))


(defun store-params ()
  (defparameter *global-inflation-radius*
    (ros::get-param "/move_base/global_costmap/inflater/inflation_radius"))
  (defparameter *local-inflation-radius*
    (ros::get-param "/move_base/local_costmap/inflater/inflation_radius"))
  t)


(defun restore-params ()
  (let ((global-costmap-server "/move_base/global_costmap/inflater")
        (local-costmap-server "/move_base/local_costmap/inflater"))
    (if (and (boundp '*global-inflation-radius*)
             (ros::wait-for-service (format nil "~A/set_parameters" global-costmap-server) 1))
      (ros::set-dynamic-reconfigure-param
        "/move_base/global_costmap/inflater" "inflation_radius"
        :double *global-inflation-radius*))
    (if (and (boundp '*local-inflation-radius*)
             (ros::wait-for-service (format nil "~A/set_parameters" local-costmap-server) 1))
      (ros::set-dynamic-reconfigure-param
        "/move_base/local_costmap/inflater" "inflation_radius"
        :double *local-inflation-radius*)))
  t)


(defun inflation-loose (&key (local-costmap-inflation-radius 0.35)
                             (global-costmap-inflation-radius 0.7))
  ;; Increase the global inflation to generate a path
  ;; that is less sensitive to differences between the map shape and the actual object placement.
  (ros::set-dynamic-reconfigure-param
    "/move_base/global_costmap/inflater" "inflation_radius" :double global-costmap-inflation-radius)
  ;; Decrease the local inflation to generate a path
  ;; that allows the robot to pass close to the object.
  (ros::set-dynamic-reconfigure-param
    "/move_base/local_costmap/inflater" "inflation_radius" :double local-costmap-inflation-radius)
  t)


(defun get-spot-coords (name)
  (if (send *ri* :simulation-modep)
    (let ((base-coords (send *scene* :spot *base-spot*))
          (spot-coords (send *scene* :spot name))
          (goal-coords nil))
      (if (and base-coords spot-coords)
        (setq goal-coords (send base-coords :transformation spot-coords)))
      (cons goal-coords nil))
    (progn
      (unless *spots*
        (setq *spots* (one-shot-subscribe "/spots_marker_array" visualization_msgs::MarkerArray)))
      (let ((spot-coords nil) (frame-id nil))
        (dolist (x (send *spots* :markers))
          (if (equal (send x :text) name)
            (progn
              (setq spot-coords (send x :pose))
              (setq frame-id (send (send x :header) :frame_id)))))
        (send (send spot-coords :position) :z 0)
        (setq spot-coords (ros::tf-pose->coords spot-coords))
        (cons spot-coords frame-id))
      )))


(defun simple-dock (&key (use-pose t))
  (unless *dock-action*
    (setq *dock-action*
          (instance ros::simple-action-client :init
                    "/dock" fetch_auto_dock_msgs::DockAction)))
  (unless (send *dock-action* :wait-for-server 5)
    (ros::ros-error "/dock action server is not started")
    (return-from simple-dock nil))
  (let ((dock-action-goal (instance fetch_auto_dock_msgs::DockActionGoal :init)))
    (when use-pose
      (let* ((timestamp (ros::time-now))
             (cret (get-spot-coords *dock-spot*))
             (frame-to-dock (car cret))
             (frame-id (cdr cret))
             (lret (send *tfl* :wait-for-transform "base_link" frame-id timestamp 5))
             (base-to-frame (send *tfl* :lookup-transform "base_link" frame-id timestamp))
             (goal-pose (ros::coords->tf-pose (send frame-to-dock :transform base-to-frame :world)))
             (pose-msg (instance geometry_msgs::PoseStamped :init)))
        (send pose-msg :header :stamp timestamp)
        (send pose-msg :header :frame_id "base_link")
        (send pose-msg :pose goal-pose)
        (send dock-action-goal :goal :dock_pose pose-msg)))
    (send *dock-action* :send-goal dock-action-goal)
    (unless (send *dock-action* :wait-for-result :timeout 60)
      (send *dock-action* :cancel-all-goals)
      (ros::ros-error "No result returned from /dock action server")
      (return-from simple-dock nil))
    (send (send *dock-action* :get-result) :docked)))


(defun dock ()
  ;; look down
  (unless (boundp '*ri*)
    (require :fetch-interface "package://fetcheus/fetch-interface.l")
    (fetch-init))
  (send *fetch* :angle-vector (send *ri* :state :potentio-vector))
  (send *fetch* :head :look-at (float-vector 800 0 500))
  (send *ri* :angle-vector (send *fetch* :angle-vector) 1000)
  (send *ri* :wait-interpolation)
  (simple-dock))


(defun undock (&key (rotate-in-place nil))
  (unless *undock-action*
    (setq *undock-action*
          (instance ros::simple-action-client :init
                    "/undock" fetch_auto_dock_msgs::UndockAction)))
  (unless (send *undock-action* :wait-for-server 5)
    (ros::ros-error "/undock action server is not started")
    (return-from undock nil))
  (send *undock-action* :send-goal
        (instance fetch_auto_dock_msgs::UndockActionGoal :init
                  :goal (instance fetch_auto_dock_msgs::UndockGoal :rotate_in_place rotate-in-place)))
  (unless (send *undock-action* :wait-for-result :timeout 60)
    (ros::ros-error "No result returned from /undock action server")
    (return-from undock nil))
  (send (send *undock-action* :get-result) :undocked))

(defun wait-until-is-charging (&key (timeout 10))
  """
  Wait for updating battery charging state especially when robots dock.
  Args:
    - key
      timeout [sec]: Set waiting time for updating /battery_state topic

  ;; If /battery_state is subscribed before /battery_state becomes true
  ;; while dock succeeds, the result will not be correct,
  ;; so wait for a certain time when docking.
  """
  (if (send *ri* :simulation-modep) (return-from wait-until-is-charging nil))
  (let* ((msg nil)
         (is-charging nil)
         (duration 0)
         (start-time (send (ros::time-now) :sec)))
    (while (not is-charging)
      (when (> duration timeout)
        (ros::ros-warn "Skip waiting for charging state because of timeout")
        (return-from wait-until-is-charging :timeout))
      (setq msg (one-shot-subscribe "/battery_state" power_msgs::BatteryState
                                    :timeout 1000))
      (if msg (setq is-charging (send msg :is_charging)))
      (setq duration (- (send (ros::time-now) :sec) start-time)))
    :charging))

(defun get-battery-charging-state (&key (timeout 1500))
  """
  Get battery charging state
  Args:
    - key
      timeout: Set waiting time for topic.
  """
   (if (send *ri* :simulation-modep) (return-from get-battery-charging-state nil))
   (let* ((msg (one-shot-subscribe "/battery_state" power_msgs::batterystate :timeout timeout))
          (is-charging (if msg (send msg :is_charging))))
     ;; You may fail to subscribe /battery_state
     ;; because of message md5 difference between melodic and indigo.
     (if (not msg) (return-from get-battery-charging-state nil))
     (if is-charging :charging :discharging)))

(defun go-to-spot (name &key (relative-pos nil) (relative-rot nil) (undock-rotate nil) (clear-costmap t))
  "Move the robot to the spot defined in /spots_marker_array topic. The reason for using relative-pos and relative-rot instead of relative-coords is that it is easier to understand if relative-pos and relative-rot are specified in the different coords (specifically, world (map) and local (spot) coords respectively). For detail, see https://github.com/jsk-ros-pkg/jsk_robot/pull/1458#pullrequestreview-1039654868
Args:
- name : The name of the spot defined in /spots_marker_array topic
- relative-pos : The robot moves to a position that is distant from the spot by relative-pos[mm]. relative-pos is specified in the world (map) coords.
- relative-rot : The robot moves to a position rotated by relative-pos[deg] from the spot. relative-rot is specified in the local (spot) coords.
- undock-rotate : If t, the robot rotates 180 degrees after undock before moving to the spot.
- clear-costmap : If t, clear costmap for obstacle avoidance before the robot moves.
"

  ;; undock if fetch is docking
  (unless (boundp '*ri*)
    (require :fetch-interface "package://fetcheus/fetch-interface.l")
    (fetch-init))
  (if clear-costmap (send *ri* :clear-costmap))
  (let ((undock-success nil))
    (block go-to-spot-undock
      (dotimes (i 3)
        (let* ((battery-charging-state (get-battery-charging-state)))
          ;; You may fail to subscribe /battery_state
          ;; because of message md5 difference between melodic and indigo.
          (unless battery-charging-state
            (ros::ros-warn "Failed to subscribe /battery_state")
            (ros::ros-warn "Skip undocking, so please make sure that Fetch is already undocked.")
            (return-from go-to-spot-undock t))
          (if (equal battery-charging-state :charging)
            (progn
              (setq undock-success (auto-undock :n-trial 3 :rotate-in-place undock-rotate)))
            (return-from go-to-spot-undock t))
          (if (not undock-success)
            (progn
              (ros::ros-error "Failed to undock")
            (send *ri* :speak "I failed to undock.")))))
      (if (not undock-success) (return-from go-to-spot nil))))
  ;; go to spot
  (let* ((ret (get-spot-coords name))
         (goal-pose (car ret))
         (frame-id (cdr ret)))
    (when relative-pos
      (setq goal-pose (send goal-pose :translate relative-pos :world)))
    (when relative-rot
      (setq goal-pose (send goal-pose :rotate relative-rot :z :local)))
    (if frame-id
      (send *ri* :move-to goal-pose :frame-id frame-id)
      (send *ri* :move-to goal-pose))))


(defun auto-dock (&key (n-trial 1) (clear-costmap t))
  (let ((success nil))
    (dotimes (i n-trial)
      (when (go-to-spot *dock-spot*
                        :relative-pos #f(-800 0 0)
                        :clear-costmap clear-costmap)
        (ros::ros-info "arrived at the dock.")
        (setq success (if (send *ri* :simulation-modep) t (dock)))
        (when success (return-from auto-dock success))))
    success))


(defun auto-undock (&key (n-trial 1) (rotate-in-place nil))
  (let ((success nil))
    (unless (boundp '*ri*)
      (require :fetch-interface "package://fetcheus/fetch-interface.l")
      (fetch-init))
    (dotimes (i n-trial)
      (ros::ros-info "trying to do undock.")
      (setq success (undock :rotate-in-place rotate-in-place))
      (when success (return-from auto-undock success)))
    (if (not success)
      (let ((enable-request (instance power_msgs::BreakerCommandRequest :init :enable t))
            (disable-request (instance power_msgs::BreakerCommandRequest :init :enable nil))
            (breaker-service-name "base_breaker"))
        (ros::wait-for-service breaker-service-name 5)
        (ros::service-call breaker-service-name disable-request)
        (ros::ros-error "Diable base breaker")
        (send *ri* :speak "I disable and enable base breaker.")
        (unix::sleep 5)
        (ros::service-call breaker-service-name enable-request)
        (ros::ros-error "Enable base breaker")))
    success))


(defun get-light-on ()
  (let* ((room-light-msg
          (one-shot-subscribe "/check_room_light/output"
                              jsk_robot_startup::RoomLight
                              :timeout 1000))
         (light-on (if room-light-msg (send room-light-msg :light_on))))
    light-on))


(defun room-light-on (&key (control-switchbot :api))
  (cond
   ((or (eq control-switchbot :en) (eq control-switchbot :jp))
    ;; Look at Google Home
    (send *fetch* :head :neck-y :joint-angle 89)
    (send *fetch* :head :neck-p :joint-angle 25)
    (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
    (send *ri* :wait-interpolation)
    ;; The accuracy of Google Home recognition is better in English than in Japanese.
    (if (eq control-switchbot :en)
      (progn
        (send *ri* :speak "OK, Google" :wait t)
        (send *ri* :speak "Turn on the light." :wait t))
      (progn
        (send *ri* :speak-jp "オッケー、グーグル" :wait t)
        (send *ri* :speak-jp "電気をつけて" :wait t)))
    (send *fetch* :head :neck-y :joint-angle 0)
    (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
    (send *ri* :wait-interpolation))
   ((eq control-switchbot :api)
    (control-device "/eng2/7f/73b2_bot_kitchen" "turnOn" :wait t)
    (control-device "/eng2/7f/73b2_bot_window" "turnOn" :wait t)
    (send *ri* :speak-jp "電気をつけました" :wait t))))


(defun room-light-off (&key (control-switchbot :api))
  (cond
   ((or (eq control-switchbot :en) (eq control-switchbot :jp))
    ;; Look at Google Home
    (send *fetch* :head :neck-y :joint-angle 89)
    (send *fetch* :head :neck-p :joint-angle 25)
    (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
    (send *ri* :wait-interpolation)
    ;; The accuracy of Google Home recognition is better in English than in Japanese.
    (if (eq control-switchbot :en)
      (progn
        (send *ri* :speak "OK, Google" :wait t)
        (send *ri* :speak "Turn off the light." :wait t))
      (progn
        (send *ri* :speak-jp "オッケー、グーグル" :wait t)
        (send *ri* :speak-jp "電気を消して" :wait t)))
    (send *fetch* :head :neck-y :joint-angle 0)
    (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
    (send *ri* :wait-interpolation))
   ((eq control-switchbot :api)
    (control-device "/eng2/7f/73b2_bot_kitchen" "turnOff" :wait t)
    (control-device "/eng2/7f/73b2_bot_window" "turnOff" :wait t)
    (send *ri* :speak-jp "電気を消しました" :wait t))))


(defun report-auto-dock ()
  (ros::ros-info "start going back to the dock.")
  (send *ri* :speak-jp "ドックに戻ります。" :wait t))

(defun report-move-to-sink-front ()
  (ros::ros-info "arrived at the kitchen stove.")
  (send *ri* :speak-jp "キッチンのコンロの前につきました。" :wait t))

(defun report-move-to-sink-front-failure ()
  (ros::ros-error "failed going to the kitchen.")
  (send *ri* :speak-jp "キッチンのコンロの前に行くのに失敗しました。" :wait t))

(defun report-move-to-trashcan-front ()
  (ros::ros-info "arrived at the trash can")
  (send *ri* :speak-jp "ゴミ箱の前につきました。" :wait t))

(defun report-move-to-trashcan-front-failure ()
  (ros::ros-error "failed going to the trash can front")
  (send *ri* :speak-jp "ゴミ箱の前に行くのに失敗しました。" :wait t))

(defun report-start-go-to-kitchen ()
  (ros::ros-info "start going to the kitchen.")
  (send *ri* :speak-jp "キッチンに向かいます。" :wait t))

(defun report-light-on ()
  (ros::ros-info "room light is already on.")
  (send *ri* :speak-jp "すでに電気がついています。" :wait t))

(defun report-light-off ()
  (ros::ros-info "room light is off.")
  (send *ri* :speak-jp "電気が消えています。" :wait t))

(defun report-auto-dock-failure ()
  (ros::ros-error "failed auto-docking")
  (send *ri* :speak-jp "ドックに失敗しました。" :wait t))

(defun report-move-to-dock-front ()
  (ros::ros-info "take a picture in front of the dock")
  (send *ri* :speak-jp "ドックの前に到着しました" :wait t))

(defun report-move-to-dock-front-failure ()
  (ros::ros-info "failed taking a picture in front of the dock")
  (send *ri* :speak-jp "ドックの前への移動に失敗しました" :wait t))

(defun report-move-to-tv-front ()
  (ros::ros-info "take a picture in front of the tv")
  (send *ri* :speak-jp "テレビの前に到着しました" :wait t))

(defun report-move-to-tv-front-failure ()
  (ros::ros-info "failed taking a picture at in front of the tv")
  (send *ri* :speak-jp "テレビの前への移動に失敗しました" :wait t))

(defun report-move-to-tv-desk ()
  (ros::ros-info "take a picture in front of the tv desk")
  (send *ri* :speak-jp "テレビの机の前に到着しました" :wait t))

(defun report-move-to-tv-desk-failure ()
  (ros::ros-info "failed taking a picture at in front of the tv desk")
  (send *ri* :speak-jp "テレビの机の前への移動に失敗しました" :wait t))

(defun report-move-to-desk-back ()
  (ros::ros-info "take a picture of tsukamoto-kun desk")
  (send *ri* :speak-jp "奥の机の写真を撮る位置に移動しました" :wait t))

(defun report-move-to-desk-back-failure ()
  (ros::ros-info "failed taking a picture of tsukamoto-kun desk")
  (send *ri* :speak-jp "奥の机の写真を撮る位置への移動に失敗しました" :wait t))

(defun report-move-to-desk-front ()
  (ros::ros-info "take a picture of obinata desk")
  (send *ri* :speak-jp "手前の机の写真を撮る位置に移動しました" :wait t))

(defun report-move-to-desk-front-failure ()
  (ros::ros-info "failed taking a picture of obinata desk")
  (send *ri* :speak-jp "手前の机の写真を撮る位置への移動に失敗しました" :wait t))

(defun report-move-to-kitchen-door-front ()
  (ros::ros-info "take a picture of kitchen in front of the door")
  (send *ri* :speak-jp "キッチンを斜めから撮る位置に移動しました" :wait t))

(defun report-move-to-kitchen-door-front-failure ()
  (ros::ros-info "failed taking a picture of kitchen in front of the door")
  (send *ri* :speak-jp "キッチンを斜めから撮る位置への移動に失敗しました" :wait t))

(defun take-photo (file-name
                   &optional (image-topic "/edgetpu_object_detector/output/image"))
  (let ((img nil))
    (unix::system (format nil "rm -f /tmp/~A" file-name))
    (setq img (one-shot-subscribe image-topic sensor_msgs::Image :timeout 1000))
    (if img
        (progn
          (write-image-file (format nil "/tmp/~A" file-name)
                            (ros::sensor_msgs/Image->image img))
          (ros::ros-info "taking a photo ~A" file-name))
        (ros::ros-error "fail saving image"))))

(defun notify-recognition (&key (location "kitchen"))
  (let* ((msg (one-shot-subscribe "/edgetpu_object_detector/output/class"
                                  jsk_recognition_msgs::ClassificationResult
                                  :timeout 3000))
         (label-names (if msg (send msg :label_names))))
    (when label-names
      (ros::ros-info (format nil "Notify app that ~A is found." label-names))
      (notify-app "object recognition"
                  (send msg :header :stamp)
                  location
                  (format nil "~A is found" label-names))
      label-names)))

(defun notify-co2 (&key (location "kitchen"))
  (let* ((msg (one-shot-subscribe "/eco2" std_msgs::UInt16
                                  :timeout 3000)))
    (when msg
      (ros::ros-info
       (format nil "Notify app that co2 concentration is measured."))
      (notify-app "CO2 concentration"
                  (ros::time-now)
                  location
                  (format nil "CO2 concentration is ~A ppm" (send msg :data))))))

(defun notify-trashcan-occupancy (&key (location "kitchen"))
 (let* ((msg (one-shot-subscribe "/trashbin_occupancy_detector/container/occupancies"
                                  jsk_recognition_msgs::BoundingBoxArray
                                  :timeout 3000))
         (occupancy (if msg (send (elt (send msg :boxes) 0) :value)))
         (notify-text (if occupancy (if (> occupancy 1.0)
                                      "Trashcan is full."
                                      "Trashcan is not full."))))
    (when occupancy
      (ros::ros-info
       (format nil "Notify app that the occupancy of trash can is measured. ~A." occupancy))
      (notify-app "trashcan occupancy"
                  (ros::time-now)
                  location
                  (format nil "~A Trashcan occupancy is ~A"
                              notify-text
                              occupancy)))))

(defun inspect-kitchen (&key (tweet t))
  (report-move-to-sink-front)
  (if tweet
    (progn
      ;; stove
      (tweet-string "I took a photo at 73B2 Kitchen stove." :warning-time 3
                    :with-image "/edgetpu_object_detector/output/image" :speak t)
      (notify-recognition :location "kitchen stove")
      (notify-co2 :location "kitchen stove")
      (take-photo "kitchen_stove.jpg")
      (send *ri* :go-pos-unsafe 0 0 -45)
      ;; sink
      (tweet-string "I took a photo at 73B2 Kitchen sink." :warning-time 3
                    :with-image "/edgetpu_object_detector/output/image" :speak t)
      (let ((img (one-shot-subscribe "/head_camera/rgb/image_rect_color" sensor_msgs::Image :timeout 1000)))
        (ros::publish "/photo_taken" img))
      (take-photo "kitchen_sink.jpg")
      (notify-recognition :location "kitchen sink"))
    (progn
      (notify-recognition :location "kitchen"))))

(defun move-to-sink-front (&key (n-trial 1) (offset #f(400 -500 0)))
  (let ((success-move-to-sink-front nil))
    (dotimes (i n-trial)
      (setq success-move-to-sink-front
            (go-to-spot "/eng2/7f/room73B2-sink-front0"
                        :relative-pos offset :undock-rotate t))
      (when success-move-to-sink-front (return)))
    success-move-to-sink-front))

(defun move-to-dock-front (&key (n-trial 1) (offset #f(0 0 0)))
  (let ((success-move-to-dock-front nil))
    (dotimes (i n-trial)
      (setq success-move-to-dock-front
            (go-to-spot *dock-spot*
                        :relative-pos offset :undock-rotate t))
      (when success-move-to-dock-front (return)))
    success-move-to-dock-front))

(defun move-to-tv-front (&key (n-trial 1) (offset #f(0 0 0)))
  (let ((success-move-to-tv-front nil))
    (dotimes (i n-trial)
      (setq success-move-to-tv-front
            (go-to-spot "/eng2/7f/room73B2-tv-front"
                        :relative-pos offset :undock-rotate t))
      (when success-move-to-tv-front (return)))
    success-move-to-tv-front))

(defun move-to-tv-desk (&key (n-trial 1) (offset #f(0 0 0)))
  (let ((success-move-to-tv-desk nil))
    (dotimes (i n-trial)
      (setq success-move-to-tv-desk
            (go-to-spot "/eng2/7f/room73B2-tv-desk"
                        :relative-pos offset :undock-rotate t))
      (when success-move-to-tv-desk (return)))
    success-move-to-tv-desk))

(defun move-to-desk-back (&key (n-trial 1) (offset #f(0 0 0)))
  (let ((success-move-to-desk-back nil))
    (dotimes (i n-trial)
      (setq success-move-to-desk-back
            (go-to-spot "/eng2/7f/room73B2-desk-back"
                        :relative-pos offset :undock-rotate t))
      (when success-move-to-desk-back (return)))
    success-move-to-desk-back))

(defun move-to-desk-front (&key (n-trial 1) (offset #f(0 0 0)))
  (let ((success-move-to-desk-front nil))
    (dotimes (i n-trial)
      (setq success-move-to-desk-front
            (go-to-spot "/eng2/7f/room73B2-desk-front"
                        :relative-pos offset :undock-rotate t))
      (when success-move-to-desk-front (return)))
    success-move-to-desk-front))

(defun move-to-kitchen-door-front (&key (n-trial 1) (offset #f(0 0 0)))
  (let ((success-move-to-kitchen-door-front nil))
    (dotimes (i n-trial)
      (setq success-move-to-kitchen-door-front
            (go-to-spot "/eng2/7f/room73B2-kitchen-door-front"
                        :relative-pos offset :undock-rotate t))
      (when success-move-to-kitchen-door-front (return)))
    success-move-to-kitchen-door-front))

(defun inspect-dock-front (&key (tweet t))
  (report-move-to-dock-front)
  (send *fetch* :angle-vector #f(20.0 75.6304 80.2141 -11.4592 98.5487 0.0 95.111 0.0 0.0 0.0))
  (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
  (send *ri* :wait-interpolation)
  (if tweet
      (progn
        (tweet-string "I took a photo in front of the dock." :warning-time 3
                      :with-image "/edgetpu_object_detector/output/image" :speak t)
        (let ((img (one-shot-subscribe "/head_camera/rgb/image_rect_color" sensor_msgs::Image :timeout 1000)))
          (ros::publish "/photo_taken" img)))))

(defun inspect-tv-front (&key (tweet t))
  (report-move-to-tv-front)
  (send *fetch* :angle-vector #f(21.5608 75.5393 80.1877 -11.5039 93.586 -0.069474 95.2016 -0.006954 -47.2843 7.53289))
  (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
  (send *ri* :wait-interpolation)
  (if tweet
      (progn
        (tweet-string "I took a photo in front of the tv." :warning-time 3
                      :with-image "/edgetpu_object_detector/output/image" :speak t)
        (let ((img (one-shot-subscribe "/head_camera/rgb/image_rect_color" sensor_msgs::Image :timeout 1000)))
          (ros::publish "/photo_taken" img)))))

(defun inspect-tv-desk (&key (tweet t))
  (report-move-to-tv-desk)
  (send *fetch* :angle-vector #f(21.5684 75.5612 80.1877 -11.4819 93.608 -0.091436 95.2235 -0.006954 -2.16963 19.5739))
  (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
  (send *ri* :wait-interpolation)
  (if tweet
      (progn
        (tweet-string "I took a photo in front of the tv." :warning-time 3
                      :with-image "/edgetpu_object_detector/output/image" :speak t)
        (let ((img (one-shot-subscribe "/head_camera/rgb/image_rect_color" sensor_msgs::Image :timeout 1000)))
          (ros::publish "/photo_taken" img)))))

(defun inspect-desk-back (&key (tweet t))
  (report-move-to-desk-back)
  (send *fetch* :angle-vector #f(21.5684 75.5832 80.1877 -11.4819 93.608 -0.04749 95.2016 -0.072829 -1.45585 10.8727))
  (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
  (send *ri* :wait-interpolation)
  (if tweet
      (progn
        (tweet-string "I took a photo of desks." :warning-time 3
                      :with-image "/edgetpu_object_detector/output/image" :speak t)
        (let ((img (one-shot-subscribe "/head_camera/rgb/image_rect_color" sensor_msgs::Image :timeout 1000)))
          (ros::publish "/photo_taken" img)))))

(defun inspect-desk-front (&key (tweet t))
  (report-move-to-desk-front)
  (send *fetch* :angle-vector #f(21.5761 75.5173 80.2097 -11.5478 93.6519 -0.04749 95.1796 -0.006954 -1.11597 10.8288))
  (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
  (send *ri* :wait-interpolation)
  (if tweet
      (progn
        (tweet-string "I took a photo of desks." :warning-time 3
                      :with-image "/edgetpu_object_detector/output/image" :speak t)
        (let ((img (one-shot-subscribe "/head_camera/rgb/image_rect_color" sensor_msgs::Image :timeout 1000)))
          (ros::publish "/photo_taken" img)))))

(defun inspect-kitchen-door-front (&key (tweet t))
  (report-move-to-kitchen-door-front)
  (send *fetch* :angle-vector #f(21.5608 75.5612 80.2316 -11.5039 93.586 -0.04749 95.1576 -0.050857 3.17796 16.3219))
  (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
  (send *ri* :wait-interpolation)
  (if tweet
      (progn
        (tweet-string "I took a photo of kitchen." :warning-time 3
                      :with-image "/edgetpu_object_detector/output/image" :speak t)
        (let ((img (one-shot-subscribe "/head_camera/rgb/image_rect_color" sensor_msgs::Image :timeout 1000)))
          (ros::publish "/photo_taken" img)))))

(defun inspect-trashcan (&key (tweet t))
  (report-move-to-trashcan-front)
  (send *fetch* :head :neck-p :joint-angle 40)
  (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
  (send *ri* :wait-interpolation)
  (if tweet
      (progn
        (tweet-string "I took a photo of 73B2 trash cans." :warning-time 3
                      :with-image "/edgetpu_object_detector/output/image" :speak t)
        (notify-recognition :location "trash cans")
        (send *ri* :go-pos-unsafe 0.2 0 0)
        (send *fetch* :head :neck-p :joint-angle 50)
        (send *ri* :angle-vector-raw (send *fetch* :angle-vector) 3000 :head-controller)
        (send *ri* :wait-interpolation)
        (tweet-string "I took a photo of 73B2 trash can inside." :warning-time 3
                      :with-image "/edgetpu_object_detector/output/image" :speak t)
        (let ((img (one-shot-subscribe "/head_camera/rgb/image_rect_color" sensor_msgs::Image :timeout 1000)))
          (ros::publish "/photo_taken" img))
        (take-photo "trashcan_inside.jpg")
        (notify-recognition :location "trash cans inside")
        (notify-trashcan-occupancy :location "trash can")
        (send *ri* :go-pos-unsafe -0.2 0 0))
    (progn
      (notify-recognition :location "trash cans"))))

(defun move-to-trashcan-front (&key (n-trial 1) (offset #f(400 -500 0)))
  (let ((success-move-to-trashcan-front nil))
    (dotimes (i n-trial)
      (setq success-move-to-trashcan-front
            (go-to-spot "/eng2/7f/room73B2-sink-front0"
                        :relative-pos offset :relative-rot -pi/2))
      (when success-move-to-trashcan-front (return)))
    (send *ri* :go-pos-unsafe 1.3 0 0)
    (send *ri* :go-pos-unsafe 0 0 -80) ;; face the front against the trash can
    success-move-to-trashcan-front))


