(require "package://cobottaeus/cobotta-utils.l")
(require "package://pr2eus/robot-interface.l")

(if (not (find-package "COBOTTA"))
    (make-package "COBOTTA"))

(defconstant cobotta::*VT_I4*		3)
(defconstant cobotta::*VT_R8*           5)
(defconstant cobotta::*VT_BSTR*		8)
(defconstant cobotta::*VT_ARRAY*   #x2000)

(defconstant cobotta::*SLVMODE_NONE*      #x0000)
(defconstant cobotta::*SLVMODE_POSE_P*    #x0001)
(defconstant cobotta::*SLVMODE_POSE_J*    #x0002)
(defconstant cobotta::*SLVMODE_POSE_T*    #x0003)
(defconstant cobotta::*SLVMODE_POSE*      #x000F)
(defconstant cobotta::*SLVMODE_ASYNC*     #x0100)
(defconstant cobotta::*SLVMODE_SYNC_WAIT* #x0200)

(defconstant cobotta::*BCAP_FUNC_Controller_Connect*    3)
(defconstant cobotta::*BCAP_FUNC_Controller_Disconnect* 4)
(defconstant cobotta::*BCAP_FUNC_Controller_GetRobot*   7)
(defconstant cobotta::*BCAP_FUNC_Controller_Execute*   17)
(defconstant cobotta::*BCAP_FUNC_Robot_Execute*        64)
(defconstant cobotta::*BCAP_FUNC_Robot_Move*           72)
(defconstant cobotta::*BCAP_FUNC_Robot_Release*        84)

(defun cobotta::error-message (bcap-res)
  (let ((code (send bcap-res :hresult)))
    (format t "~A ~X~%" code code)
    (if (< code 0) (setq code (+ #x100000000 code)))
    (format nil "ERROR_CODE ~X (~A)" code
            (case code
                  (#x80070057 "One or more arguments are invalid")
                  (#x8150001b "Argument is incorrect")
                  (#x81501025 "Command isn't executable while error occurs")
                  (#x83500121 "SlvMove command was executed in other than the Slave mode")
                  (#x83501024 "Can't take arm semaphore")
                  (#x83501029 "Set IP address for the executable token to execute the command")
                  (#x83501032 "Command isn't executable in Slave mode")
                  (#x83201501 "Destination position is out of robot motion range")
                  (#x83201502 "Destination position is out of robot motion range")
                  (#x83201503 "Destination position is out of robot motion range")
                  (#x83201504 "Can't move because the path is too close to the singular point")
                  (#x83201505 "Can't move because the path is too close to the singular point")
                  (#x83201506 "Can't move because the path is too close to the singular point")
                  (#x83500262 "The target position of HandMoveAH exceeds software limit")
                  (#x83500314 "It is failed by hand movement setting")
                  (t          "Unknown error message")))))

(ros::roseus-add-srvs "bcap_service")
(ros::roseus-add-msgs "bcap_service")

(defclass cobotta-interface
  :super robot-interface
  :slots (controller-handle robot-handle move-robot)
  )

(defmethod cobotta-interface
  (:init
   (&rest args)
   (let (bcap-req bcap-res)
     (sys::dispose-hook self t)
     (prog1
         (send-super* :init :robot cobotta-robot :joint-states-topic "/cobotta/joint_states" :groupname "cobotta_interface" args)
#|
       (setq move-robot (instance cobotta-robot :init))
|#
       (ros::subscribe "/cobotta/CurMode" std_msgs::Int32 #'send self :mode-callback :groupname groupname)
       (ros::advertise "/cobotta/ChangeMode" std_msgs::Int32 1)
       (unless (ros::wait-for-service "bcap_service" 5) ;; wait 5 sec
         (ros::ros-error "Could not find \"bcap_service\". Please start bcap_service/launch/bcap_service.launch"))
       (send self :controller-connect)
       (if controller-handle
           (let ((robot-handle (ros::get-param "/bcap_service/robot_handle" nil)) ret)
             ;; if you found /bcap_service/robot_handle, make sure to remove arm semaphore
             (when robot-handle
               (setq robot-handle (round robot-handle))
               (setq ret (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "TakeArmState" -1))
               (when (not (equal (send ret :vntret :value) "0"))
                 (ros::ros-info "Remove existing arm semaphore for robot-handle ~A" robot-handle)
                 (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "Givearm" "")))
             (send self :get-robot))
         (ros::ros-error "Could not get Robot Handle"))
       ;; normal mode
       (ros::ros-info "set Normal mode")
       (send self :clear-error)
       (send self :take-arm)
       (send self :motor-on)
       (send self :slave-change-mode #x0)
       self)))
  ;; fake :angle-vector
  (:angle-vector
   (&rest args)
   (send* self :move-robot args))
  (:dispose () ;; dispose is set but never called due to gentemp and subscribe ( ;; avoid gc line in EuslispSubscriptionCallbackHelper)
   (format *error-output* ";; dispose ~A~%" self)
   (when robot-handle
     (format *error-output* ";; give arm (release semaphore)~%")
     (send self :give-arm)
     (format *error-output* ";; release robot (~A)~%" robot-handle)
     (send self :release-robot)
     (ros::delete-param "/bcap_service/robot_handle")
     )
   (when controller-handle
     (format *error-output* ";; disconnect controller (~A)~%" controller-handle)
     (send self :controller-disconnect)
     (ros::delete-param "/bcap_service/controller_handle")))
  ;; default robot-interface methods
  (:mode-callback
   (msg)
   (send self :set-robot-state1 :mode (send msg :data)))
  (:default-controller () (send self :rarm-controller))
  (:rarm-controller ()
   (list
    (list
     (cons :controller-action "cobotta/arm_controller/follow_joint_trajectory")
     (cons :controller-state "cobotta/arm_controller/state")
     (cons :action-type control_msgs::FollowJointTrajectoryAction)
     (cons :joint-names (list "joint_1" "joint_2" "joint_3" "joint_4" "joint_5" "joint_6")))))
  (:mode
   (&optional mode)
   (let ()
     (case mode
           (:slave
            (setq mode (logior cobotta::*SLVMODE_POSE_J* cobotta::*SLVMODE_SYNC_WAIT*)))
           (:normal
            (setq mode 0)))
     (if (numberp mode)
         (while (not (equal mode (setq cur-mode (send self :state :mode))))
           (ros::ros-info "Current mode is ~A and publish /cobotta/ChangeMode ~A" cur-mode mode)
           (ros::publish "/cobotta/ChangeMode" (instance std_msgs::Int32 :init :data mode))
           (unix:sleep 1)))
     mode))

  ;; b-Cap specific commands
  (:send-bcap-service
   (function-id &rest args)
   (let (bacp-req bcap-res arg-list)
     (setq bcap-req (instance bcap_service::bcaprequest :init))
     (send bcap-req :func_id function-id)
     (dolist (arg (reverse (remove nil args))) ;; skip (nil)
       (cond ((integerp arg)
              (push (instance bcap_service::variant :init :vt cobotta::*VT_I4* :value arg) arg-list))
             ((floatp arg)
              (push (instance bcap_service::variant :init :vt cobotta::*VT_R8* :value arg) arg-list))
             ((stringp arg)
              (push (instance bcap_service::variant :init :vt cobotta::*VT_BSTR* :value arg) arg-list))
             ((float-vector-p arg)
              (let ((vt (logior cobotta::*VT_R8* cobotta::*VT_ARRAY*))
                    (value (apply #'concatenate string (butlast (mapcan #'(lambda (x y) (list (string x) y)) (coerce arg cons) (make-list (length arg) :initial-element ","))))))
                (push (instance bcap_service::variant :init :vt vt :value value) arg-list)))
             ((integer-vector-p arg)
              (let ((vt (logior cobotta::*VT_I4* cobotta::*VT_ARRAY*))
                    (value (apply #'concatenate string (butlast (mapcan #'(lambda (x y) (list (string x) y)) (coerce arg cons) (make-list (length arg) :initial-element ","))))))
                (push (instance bcap_service::variant :init :vt vt :value value) arg-list)))
             ((listp arg)
              (let ((vt (logior cobotta::*VT_BSTR* cobotta::*VT_ARRAY*))
                    (value (apply #'concatenate string (butlast (mapcan #'(lambda (x y) (list (string x) y)) (coerce arg cons) (make-list (length arg) :initial-element ","))))))
                (push (instance bcap_service::variant :init :vt vt :value value) arg-list)))
             (t
              (ros::ros-error "Unknown variant ~A" arg))))
     (send bcap-req :vntArgs arg-list)
     (ros::ros-debug "call {func_id: ~A, vntArgs: ~A}" function-id (mapcar #'(lambda (arg) (format nil "{vt: ~A, value: ~A}" (send arg :vt) (send arg :value))) arg-list))
     (setq bcap-res (ros::service-call "bcap_service" bcap-req))
     (cond ((= (send bcap-res :hresult) 0))
           (t
            (ros::ros-warn "Call {func_id: ~A, vntArgs: ~A}" function-id (mapcar #'(lambda (arg) (format nil "{vt: ~A, value: ~A}" (send arg :vt) (send arg :value))) arg-list))
            (ros::ros-warn " ** ~A **" (cobotta::error-message bcap-res))))
     bcap-res))
  (:controller-connect ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Controller_Connect* "" "CaoProv.DENSO.VRC" "localhost" ""))
     (when (/= (send res :hresult) 0) ;; if failed, disconnect and connect again
       (ros::ros-warn "Failed to connect controller, disconnect and connect again")
       (setq controller-handle (ros::get-param "/bcap_service/controller_handle"))
       (unless controller-handle
         (ros::ros-error "Could not find cached controller-handle")
         (return-from :controller-connect))
       (setq controller-handle (round controller-handle))
       (setq robot-handle (round (ros::get-param "/bcap_service/robot_handle")))
       (send self :controller-disconnect)
       (send self :release-robot)
       (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Controller_Connect* "" "CaoProv.DENSO.VRC" "localhost" "")))
     (cond ((and (= (send res :hresult) 0)
                 (> (length (send res :vntret :value)) 0))
            (setq controller-handle (read-from-string (send res :vntret :value))) ;; controller-handle is string
            (ros::set-param "/bcap_service/controller_handle" controller-handle))
           (t
            (ros::ros-error "Could not get controller_handle, get controller-handle from rosparam")
            (setq controller-handle (ros::get-param "/bcap_service/controller_handle"))
            (if (numberp controller-handle)
                (setq controller-handle (round controller-handle))
              (ros::ros-error "Could not get controller_handle. Could you check [F6 setting] -> [F5 Comunication and Token] -> [F2 Network and Permission] of your TP?"))))
     (ros::ros-info "controller-handle ~A" controller-handle)))
  (:controller-disconnect (&optional c-handle)
   (let (res)
     (if c-handle (setq controller-handle c-handle))
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Controller_Disconnect* controller-handle))))
  (:get-robot ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Controller_GetRobot* controller-handle "Arm0" ""))
     (cond ((= (send res :hresult) 0)
            (setq robot-handle (read-from-string (send res :vntret :value)))
            (ros::set-param "/bcap_service/robot_handle" robot-handle))
           (t
            (ros::ros-error "Could not get robot_handle, get robot-handle from rosparam")
            (setq robot-handle (round (ros::get-param "/bcap_service/robot_handle")))))
     (ros::ros-info "robot-handle ~A" robot-handle)))
  (:release-robot (&optional r-handle)
   (let (res)
     (if r-handle (setq robot-handle r-handle))
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Release* robot-handle))))
  (:take-arm ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "Takearm" 0 1))))
  (:give-arm ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "Givearm" ""))))
  (:motor-on ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "Motor" 1 0))))
  (:motor-off ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "Motor" 0 1))))
  (:clear-error ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Controller_Execute* controller-handle "ClearError" ""))))
  (:slave-change-mode (&optional (mode 0))
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "slvChangeMode" mode))))
  (:cur-jnt ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "CurJnt" ""))
     (if (and (= (send res :hresult) 0)
              (> (length (send res :vntret :value)) 0))
         (let* ((str (send res :vntret :value)) ;; split str with #\,
                (cnt 1) (len (length str)) (ret nil))
           (while (setq cnt (position #\, str))
             (push (read-from-string (subseq str 0 cnt)) ret)
             (incf cnt)
             (setq str (subseq str cnt)))
           (push (read-from-string str) ret)
           (coerce (reverse ret) float-vector))
       (ros::ros-warn "Could not get CurJnt result: ~A, value: ~A" (send res :hresult) (send res :vntret :value)))))
  (:slv-move (av)
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "slvMove" av))))
  (:move-robot (av &optional (tm 3000) (duration-factor 0.756338))
   (let (res target-pos target-rpy target-str min-time speed-str)
     (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "ExtSpeed" 100 100 100)
#|
     (send move-robot :move-to (make-coords))
     (send move-robot :angle-vector av)
     (setq target-pos (send move-robot :rarm :end-coords :worldpos))
     (setq target-rot (car (rpy-angle (send move-robot :rarm :end-coords :worldrot))))
     (setq target-str (format nil "P(~f,~f,~f,~f,~f,~f,261)"
                              (elt target-pos 0) (elt target-pos 1) (elt target-pos 2)
                              (rad2deg (elt target-rot 2)) (rad2deg (elt target-rot 1)) (rad2deg (elt target-rot 0))))
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Move* robot-handle 1 target-str ""))
|#
     (setq min-time (* 1000 (send self :angle-vector-duration (send self :state :potentio-vector) av 1 0.2)))
     (setq tm (* duration-factor tm)) ;; 0.85 is magic number to calibrate :angle-vector-duration to real duration
     (setq speed-str (format nil "Speed=~A" (round (* 100 (/ min-time (max tm min-time))))))
     (ros::ros-debug "tm: ~A, min-time :~A, speed-str :~A" tm min-time speed-str)
     (setq target-str "J(")
     (dotimes (i (length av))
       (setq target-str (format nil "~A~f~A" target-str (elt av i)
                                (if (< i (1- (length av))) "," ")"))))
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Move* robot-handle 1 target-str speed-str))
     (= (send res :hresult) 0)))
  (:fill-buffer ()
   (let (av)
     (setq av (send self :cur-jnt))
     (if av (dotimes (i 4) (setq ret (send self :slv-move av))))))
  (:reflect-real-state ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Robot_Execute* robot-handle "slvChangeMode" mode))))
  ;; cobotta
  (:hand-hold-state
   ()
   (let (res)
     (setq res (send self :send-bcap-service cobotta::*BCAP_FUNC_Controller_Execute* controller-handle "HandHoldState" ""))
     (when (= (send res :hresult) 0)
       (not (equal (send res :vntret :value) "0")))))
  (:start-grasp
   (&key (pos 29))
   (send self :send-bcap-service cobotta::*BCAP_FUNC_Controller_Execute* controller-handle "HandMoveAH" (list pos 100 20 "DetectOn"))
   (send self :hand-hold-state))
  (:stop-grasp
   ()
   (send self :send-bcap-service cobotta::*BCAP_FUNC_Controller_Execute* controller-handle "HandMoveA" #i(30 50)))
  )

(defun cobotta-exit (&optional (n 0))
  (format *error-output* ";; cobotta-exit~%")
  (if (boundp '*ri*) (send *ri* :dispose))
  (ros-exit n))

;; rename exit -> ros-exit and define new (exit) that calls cobotta-exit
(unless (fboundp 'ros-exit)
  (setf (symbol-function 'ros-exit) (symbol-function 'exit))
  (defun exit (&optional (n 0)) (cobotta-exit n)))
(setq sys::*exit-hook* 'cobotta-exit)

(defun cobotta-init (&optional (create-viewer))
  (unless (boundp '*cobotta*) (cobotta) (send *cobotta* :reset-pose))
  (unless (ros::ok) (ros::roseus "cobotta_eus_interface"))
  (unless (boundp '*ri*) (setq *ri* (instance cobotta-interface :init)))

  (ros::spin-once)
  (send *ri* :spin-once)

  (when create-viewer (objects (list *cobotta*)))
  )
